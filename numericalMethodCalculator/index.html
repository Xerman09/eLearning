<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improved Bisection Method Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .calculator-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .parsed-function {
            background-color: #f0f8ff;
            padding: 12px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 18px;
            text-align: center;
        }
        
        .options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .option-group {
            flex: 1;
            min-width: 200px;
        }
        
        .radio-group, .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 8px;
        }
        
        .radio-option, .checkbox-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%;
            margin-top: 10px;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .solution-container {
            margin-top: 30px;
        }
        
        .input-display {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 18px;
        }
        
        .iterations-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .iteration-box {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .iteration-header {
            background-color: #3498db;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 12px;
            font-weight: bold;
        }
        
        .iteration-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .math-display {
            margin: 10px 0;
            font-size: 16px;
        }
        
        .explanation {
            background-color: #f5f5f5;
            padding: 12px;
            border-left: 4px solid #3498db;
            margin-top: 10px;
        }
        
        .error-message {
            color: #e74c3c;
            margin-top: 8px;
            font-size: 14px;
        }
        
        .interval-inputs {
            display: flex;
            gap: 15px;
        }
        
        .interval-input {
            flex: 1;
        }
        
        .parameters-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        
        .parameter-group {
            flex: 1;
            min-width: 120px;
        }
        
        .result-summary {
            background-color: #e8f4fc;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
        }
        
        .final-root {
            color: #2c3e50;
            font-size: 20px;
        }
        
        .error-value {
            color: #3498db;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        table th, table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        table th {
            background-color: #3498db;
            color: white;
            padding: 10px;
        }
        
        table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        table tr:hover {
            background-color: #e6f7ff;
        }
        
        @media (max-width: 768px) {
            .options-container,
            .interval-inputs {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <h1>Improved Bisection Method Calculator</h1>
    
    <div class="calculator-container">
        <div class="input-group">
            <label for="function-input">Enter Function f(x):</label>
            <input type="text" id="function-input" placeholder="e.g., 2x^3 - 2x - 5 or sin(x) - x/2" value="2x^3 - 2x - 5">
            <div class="parsed-function" id="parsed-function">f(x) = </div>
        </div>
        
        <div class="explanation-box" id="interval-explanation" style="background-color: #e8f8f5; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 5px solid #2ecc71;">
            <h3 style="margin-top: 0; color: #27ae60;">Finding Root Intervals</h3>
            <p>For the example function <strong>f(x) = 2x³ - 2x - 5</strong>, we evaluate at consecutive integers to find a sign change:</p>
            <div id="interval-demo-table"></div>
            <p>We find that <strong>f(1) = -5</strong> and <strong>f(2) = 7</strong> have opposite signs, so a root exists in the interval [1, 2].</p>
            <p><strong>This is why our improved algorithm works better:</strong> Instead of jumping to large intervals (like -10 to 10), we check consecutive integers first to find sign changes more efficiently.</p>
        </div>
        
        <div class="options-container">
            <div class="option-group">
                <label>Root Finding Method:</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="interval-root" name="root-method" value="interval" checked>
                        <label for="interval-root">Find root in interval</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="any-root" name="root-method" value="any">
                        <label for="any-root">Find any root</label>
                    </div>
                </div>
            </div>
            
            <div class="option-group">
                <label>Error Calculation:</label>
                <div class="checkbox-group">
                    <div class="checkbox-option">
                        <input type="checkbox" id="absolute-error" name="error-type" value="absolute" checked>
                        <label for="absolute-error">Absolute Error</label>
                    </div>
                    <div class="checkbox-option">
                        <input type="checkbox" id="relative-error" name="error-type" value="relative">
                        <label for="relative-error">Relative Percent Error</label>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="interval-inputs" id="interval-container">
            <div class="interval-input">
                <label for="lower-bound">Lower Bound (a):</label>
                <input type="number" id="lower-bound" placeholder="e.g., 1" value="1" step="any">
            </div>
            <div class="interval-input">
                <label for="upper-bound">Upper Bound (b):</label>
                <input type="number" id="upper-bound" placeholder="e.g., 2" value="2" step="any">
            </div>
        </div>
        
        <div class="parameters-container">
            <div class="parameter-group">
                <label for="tolerance">Tolerance (ε):</label>
                <input type="number" id="tolerance" placeholder="e.g., 0.0001" value="0.0001" min="0" step="any">
            </div>
            <div class="parameter-group">
                <label for="max-iterations">Max Iterations:</label>
                <input type="number" id="max-iterations" placeholder="e.g., 100" value="50" min="1" step="1">
            </div>
        </div>
        
        <div class="error-message" id="error-message"></div>
        
        <button id="calculate-btn">Calculate Root</button>
    </div>
    
    <div class="solution-container" id="solution-container" style="display: none;">
        <h2>Solution Steps</h2>
        <div class="input-display" id="input-display"></div>
        
        <div id="interval-finding-results" style="background-color: #eaf2f8; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 5px solid #3498db;">
            <h3 style="margin-top: 0; color: #2980b9;">Interval Search Results</h3>
            <p id="interval-search-explanation"></p>
        </div>
        
        <div class="iterations-container" id="iterations-container"></div>
        <div class="result-summary" id="result-summary"></div>
        
        <h3>Solution Table</h3>
        <div id="solution-table-container"></div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const functionInput = document.getElementById('function-input');
            const parsedFunction = document.getElementById('parsed-function');
            const intervalRoot = document.getElementById('interval-root');
            const anyRoot = document.getElementById('any-root');
            const intervalContainer = document.getElementById('interval-container');
            const lowerBound = document.getElementById('lower-bound');
            const upperBound = document.getElementById('upper-bound');
            const tolerance = document.getElementById('tolerance');
            const maxIterations = document.getElementById('max-iterations');
            const absoluteError = document.getElementById('absolute-error');
            const relativeError = document.getElementById('relative-error');
            const calculateBtn = document.getElementById('calculate-btn');
            const errorMessage = document.getElementById('error-message');
            const solutionContainer = document.getElementById('solution-container');
            const inputDisplay = document.getElementById('input-display');
            const iterationsContainer = document.getElementById('iterations-container');
            const resultSummary = document.getElementById('result-summary');
            const solutionTableContainer = document.getElementById('solution-table-container');
            
            // Handle root method selection
            intervalRoot.addEventListener('change', toggleIntervalInputs);
            anyRoot.addEventListener('change', toggleIntervalInputs);
            
            function toggleIntervalInputs() {
                if (intervalRoot.checked) {
                    intervalContainer.style.display = 'flex';
                } else {
                    intervalContainer.style.display = 'none';
                }
            }
            
            // Parse function input and display in mathematical form
            function updateParsedFunction() {
                try {
                    const expression = functionInput.value.trim();
                    if (expression) {
                        // Convert to LaTeX
                        const latex = '\\(f(x) = ' + math.parse(expression).toTex() + '\\)';
                        parsedFunction.innerHTML = latex;
                        renderMathInElement(parsedFunction);
                        errorMessage.textContent = '';
                    } else {
                        parsedFunction.textContent = 'f(x) = ';
                    }
                } catch (error) {
                    parsedFunction.textContent = 'f(x) = ' + functionInput.value;
                    errorMessage.textContent = 'Invalid function syntax';
                }
            }
            
            // Initial function parsing
            updateParsedFunction();
            
            // Listen for input changes
            functionInput.addEventListener('input', updateParsedFunction);
            
            // Calculate button click handler
            calculateBtn.addEventListener('click', function() {
                errorMessage.textContent = '';
                
                try {
                    const expression = functionInput.value.trim();
                    if (!expression) {
                        throw new Error('Please enter a function');
                    }
                    
                    // Create function from input
                    const f = x => math.evaluate(expression, { x });
                    
                    // Get parameters
                    const tol = parseFloat(tolerance.value) || 0.0001;
                    const maxIter = parseInt(maxIterations.value) || 50;
                    
                    let result;
                    
                    if (intervalRoot.checked) {
                        // Find root in specified interval
                        const a = parseFloat(lowerBound.value);
                        const b = parseFloat(upperBound.value);
                        
                        if (isNaN(a) || isNaN(b)) {
                            throw new Error('Please enter valid interval bounds');
                        }
                        
                        if (a >= b) {
                            throw new Error('Upper bound must be greater than lower bound');
                        }
                        
                        const fa = f(a);
                        const fb = f(b);
                        
                        if (fa * fb >= 0) {
                            throw new Error('Function must have opposite signs at interval endpoints (f(a) * f(b) < 0)');
                        }
                        
                        result = bisectionMethod(f, a, b, tol, maxIter);
                    } else {
                        // Find any root using improved interval search
                        result = findAnyRootImproved(f, tol, maxIter);
                    }
                    
                    // Display results
                    displayResults(result, f, expression);
                    
                } catch (error) {
                    errorMessage.textContent = error.message || 'An error occurred';
                }
            });
            
            // Bisection method implementation
            function bisectionMethod(f, a, b, tol, maxIter) {
                let iterations = [];
                let iteration = 0;
                let c, fa, fb, fc;
                let error = Infinity;
                let prevC = null;
                
                fa = f(a);
                fb = f(b);
                
                while (iteration < maxIter && error > tol) {
                    // Calculate midpoint
                    c = (a + b) / 2;
                    fc = f(c);
                    
                    // Calculate errors if applicable
                    if (prevC !== null) {
                        error = Math.abs(c - prevC);
                    }
                    
                    // Store iteration data
                    iterations.push({
                        iteration: iteration + 1,
                        a: a,
                        b: b,
                        c: c,
                        fa: fa,
                        fb: fb,
                        fc: fc,
                        error: prevC !== null ? Math.abs(c - prevC) : null,
                        relError: prevC !== null ? Math.abs((c - prevC) / c) * 100 : null
                    });
                    
                    // Update interval
                    if (fc === 0) {
                        // Exact root found
                        break;
                    } else if (fa * fc < 0) {
                        b = c;
                        fb = fc;
                    } else {
                        a = c;
                        fa = fc;
                    }
                    
                    prevC = c;
                    iteration++;
                }
                
                return {
                    root: c,
                    iterations: iterations,
                    converged: error <= tol,
                    iterationCount: iteration
                };
            }
            
            // Improved method to find any root by checking sequential integers first
            function findAnyRootImproved(f, tol, maxIter) {
                // Log the search steps
                const searchLog = [];
                
                // First try consecutive integers from -10 to 10
                const searchRange = 20;
                
                // Sequential search from 0 outward (this is the key improvement)
                for (let i = 0; i < searchRange; i++) {
                    // Check positive side: i to i+1
                    if (i < searchRange - 1) {
                        let fa = f(i);
                        let fb = f(i+1);
                        searchLog.push({ a: i, b: i+1, fa: fa, fb: fb, comment: "Checking consecutive integers" });
                        
                        if (fa * fb <= 0) {
                            // Found a sign change!
                            document.getElementById('error-message').innerHTML = 
                                `<span style="color: green;">Found root interval: [${i}, ${i+1}] where f(${i}) = ${fa.toFixed(4)} and f(${i+1}) = ${fb.toFixed(4)}</span>`;
                            return bisectionMethod(f, i, i+1, tol, maxIter);
                        }
                    }
                    
                    // Check negative side: -i to -(i+1)
                    if (i > 0) {
                        let fa = f(-i);
                        let fb = f(-(i+1));
                        searchLog.push({ a: -i, b: -(i+1), fa: fa, fb: fb, comment: "Checking consecutive negative integers" });
                        
                        if (fa * fb <= 0) {
                            // Found a sign change!
                            document.getElementById('error-message').innerHTML = 
                                `<span style="color: green;">Found root interval: [${-(i+1)}, ${-i}] where f(${-(i+1)}) = ${fb.toFixed(4)} and f(${-i}) = ${fa.toFixed(4)}</span>`;
                            return bisectionMethod(f, -(i+1), -i, tol, maxIter);
                        }
                    }
                }
                
                // If no roots found in integer intervals, try smaller increments
                document.getElementById('error-message').innerHTML = 
                    `<span style="color: orange;">No root found between consecutive integers. Trying smaller increments...</span>`;
                
                const step = 0.5;
                for (let x = -searchRange; x <= searchRange; x += step) {
                    let fa = f(x);
                    let fb = f(x + step);
                    searchLog.push({ a: x, b: x+step, fa: fa, fb: fb, comment: "Checking half-unit intervals" });
                    
                    if (fa * fb <= 0) {
                        document.getElementById('error-message').innerHTML = 
                            `<span style="color: green;">Found root interval: [${x.toFixed(2)}, ${(x+step).toFixed(2)}] where f(${x.toFixed(2)}) = ${fa.toFixed(4)} and f(${(x+step).toFixed(2)}) = ${fb.toFixed(4)}</span>`;
                        return bisectionMethod(f, x, x + step, tol, maxIter);
                    }
                }
                
                // If still no roots found, try broader ranges
                document.getElementById('error-message').innerHTML = 
                    `<span style="color: orange;">No root found in close range. Searching broader intervals...</span>`;
                
                const ranges = [
                    { a: -50, b: 50 },
                    { a: -100, b: 100 },
                    { a: -1000, b: 1000 }
                ];
                
                for (let range of ranges) {
                    for (let x = range.a; x < range.b; x += 5) {
                        let fa = f(x);
                        let fb = f(x + 5);
                        searchLog.push({ a: x, b: x+5, fa: fa, fb: fb, comment: "Searching broader range" });
                        
                        if (fa * fb <= 0) {
                            document.getElementById('error-message').innerHTML = 
                                `<span style="color: green;">Found root interval in broader search: [${x}, ${x+5}] where f(${x}) = ${fa.toFixed(4)} and f(${x+5}) = ${fb.toFixed(4)}</span>`;
                            return bisectionMethod(f, x, x + 5, tol, maxIter);
                        }
                    }
                }
                
                // If we get here, no roots were found
                console.log("Search log:", searchLog);
                throw new Error('Could not find an interval containing a root. Try specifying an interval.');
            }
            
            // Display results in mathematical form with explanations
            function displayResults(result, f, expression) {
                solutionContainer.style.display = 'block';
                
                // Format the input function
                const latexExpression = '\\(f(x) = ' + math.parse(expression).toTex() + '\\)';
                inputDisplay.innerHTML = latexExpression;
                
                // Update interval finding explanation based on the method used
                const intervalSearchExplanation = document.getElementById('interval-search-explanation');
                if (intervalRoot.checked) {
                    // User specified interval
                    const a = parseFloat(lowerBound.value);
                    const b = parseFloat(upperBound.value);
                    const fa = f(a);
                    const fb = f(b);
                    
                    intervalSearchExplanation.innerHTML = `
                        <strong>User-specified interval:</strong> [${a}, ${b}]<br>
                        <strong>Function values:</strong> f(${a}) = ${fa.toFixed(6)} and f(${b}) = ${fb.toFixed(6)}<br>
                        <strong>Verification:</strong> Since f(${a}) and f(${b}) have opposite signs (${fa.toFixed(6)} × ${fb.toFixed(6)} < 0), 
                        there is at least one root in this interval.
                    `;
                } else {
                    // Automatic interval search
                    const a = result.iterations[0].a;
                    const b = result.iterations[0].b;
                    const fa = result.iterations[0].fa;
                    const fb = result.iterations[0].fb;
                    
                    intervalSearchExplanation.innerHTML = `
                        <strong>Automatically found interval:</strong> [${a}, ${b}]<br>
                        <strong>Function values:</strong> f(${a}) = ${fa.toFixed(6)} and f(${b}) = ${fb.toFixed(6)}<br>
                        <strong>Search method:</strong> The algorithm started checking integer values and found that 
                        between x=${a} and x=${b}, the function changes sign (${fa.toFixed(6)} × ${fb.toFixed(6)} < 0), 
                        indicating a root exists in this interval.
                    `;
                }
                
                // Clear previous iterations
                iterationsContainer.innerHTML = '';
                
                // Add each iteration
                result.iterations.forEach(iter => {
                    const iterBox = document.createElement('div');
                    iterBox.className = 'iteration-box';
                    
                    const iterHeader = document.createElement('div');
                    iterHeader.className = 'iteration-header';
                    iterHeader.textContent = `Iteration ${iter.iteration}`;
                    
                    const iterContent = document.createElement('div');
                    iterContent.className = 'iteration-content';
                    
                    // Interval values
                    const intervalDiv = document.createElement('div');
                    intervalDiv.className = 'math-display';
                    intervalDiv.innerHTML = `
                        \\(a = ${iter.a.toFixed(6)}\\)
                        \\(f(a) = ${iter.fa.toFixed(6)}\\)
                        <br>
                        \\(b = ${iter.b.toFixed(6)}\\)
                        \\(f(b) = ${iter.fb.toFixed(6)}\\)
                    `;
                    
                    // Midpoint calculation
                    const midpointDiv = document.createElement('div');
                    midpointDiv.className = 'math-display';
                    midpointDiv.innerHTML = `
                        \\(c = \\frac{a + b}{2} = \\frac{${iter.a.toFixed(6)} + ${iter.b.toFixed(6)}}{2} = ${iter.c.toFixed(6)}\\)
                        <br>
                        \\(f(c) = f(${iter.c.toFixed(6)}) = ${iter.fc.toFixed(6)}\\)
                    `;
                    
                    // Error calculations if available
                    let errorDiv = document.createElement('div');
                    errorDiv.className = 'math-display';
                    
                    if (iter.error !== null) {
                        let errorContent = '';
                        
                        if (absoluteError.checked) {
                            errorContent += `\\(\\text{Absolute Error} = |c_{${iter.iteration}} - c_{${iter.iteration-1}}| = ${iter.error.toFixed(6)}\\)<br>`;
                        }
                        
                        if (relativeError.checked) {
                            errorContent += `\\(\\text{Relative Error} = \\frac{|c_{${iter.iteration}} - c_{${iter.iteration-1}}|}{|c_{${iter.iteration}}|} \\times 100\\% = ${iter.relError.toFixed(6)}\\%\\)`;
                        }
                        
                        errorDiv.innerHTML = errorContent;
                    } else {
                        errorDiv.innerHTML = '\\(\\text{Error calculation will appear after the first iteration}\\)';
                    }
                    
                    // Explanation
                    const explanationDiv = document.createElement('div');
                    explanationDiv.className = 'explanation';
                    
                    // Build explanation text based on the iteration results
                    let explanationText = '';
                    
                    if (iter.iteration === 1) {
                        explanationText = `In this first iteration, we start with the interval [${iter.a.toFixed(4)}, ${iter.b.toFixed(4)}]. 
                        We calculate the midpoint c = ${iter.c.toFixed(6)} and evaluate f(c) = ${iter.fc.toFixed(6)}.`;
                    } else {
                        explanationText = `We continue with the new interval [${iter.a.toFixed(4)}, ${iter.b.toFixed(4)}]. 
                        The midpoint is c = ${iter.c.toFixed(6)} with f(c) = ${iter.fc.toFixed(6)}.`;
                    }
                    
                    // Add explanation about which subinterval is chosen
                    if (iter.fc === 0) {
                        explanationText += ` We found an exact root at x = ${iter.c.toFixed(6)}.`;
                    } else if (iter.fa * iter.fc < 0) {
                        explanationText += ` Since f(a) × f(c) < 0 (${iter.fa.toFixed(6)} × ${iter.fc.toFixed(6)} < 0), 
                        a root exists in the left subinterval [a, c]. So for the next iteration, we'll set b = c and continue.`;
                    } else {
                        explanationText += ` Since f(a) × f(c) > 0 (${iter.fa.toFixed(6)} × ${iter.fc.toFixed(6)} > 0), 
                        a root exists in the right subinterval [c, b]. So for the next iteration, we'll set a = c and continue.`;
                    }
                    
                    // Add error information if available
                    if (iter.error !== null) {
                        if (absoluteError.checked) {
                            explanationText += ` The absolute error is ${iter.error.toFixed(6)}.`;
                        }
                        
                        if (relativeError.checked) {
                            explanationText += ` The relative error is ${iter.relError.toFixed(6)}%.`;
                        }
                    }
                    
                    explanationDiv.textContent = explanationText;
                    
                    // Append all elements
                    iterContent.appendChild(intervalDiv);
                    iterContent.appendChild(midpointDiv);
                    iterContent.appendChild(errorDiv);
                    iterContent.appendChild(explanationDiv);
                    
                    iterBox.appendChild(iterHeader);
                    iterBox.appendChild(iterContent);
                    
                    iterationsContainer.appendChild(iterBox);
                });
                
                // Create solution table
                createSolutionTable(result.iterations);
                
                // Render all math expressions
                renderMathInElement(iterationsContainer);
                renderMathInElement(inputDisplay);
                
                // Add result summary
                let summaryText = '';
                if (result.converged) {
                    summaryText = `
                        <div class="final-root">Root found: x = ${result.root.toFixed(8)}</div>
                        <div>Function value at root: f(x) = ${f(result.root).toFixed(8)}</div>
                        <div>Converged in ${result.iterationCount} iterations</div>
                    `;
                    
                    if (absoluteError.checked && result.iterations.length > 1) {
                        const lastIter = result.iterations[result.iterations.length - 1];
                        summaryText += `<div class="error-value">Final absolute error: ${lastIter.error.toFixed(8)}</div>`;
                    }
                    
                    if (relativeError.checked && result.iterations.length > 1) {
                        const lastIter = result.iterations[result.iterations.length - 1];
                        summaryText += `<div class="error-value">Final relative error: ${lastIter.relError.toFixed(8)}%</div>`;
                    }
                } else {
                    summaryText = `
                        <div>Method did not converge within ${maxIterations.value} iterations</div>
                        <div class="final-root">Best approximation: x = ${result.root.toFixed(8)}</div>
                        <div>Function value: f(x) = ${f(result.root).toFixed(8)}</div>
                    `;
                }
                
                resultSummary.innerHTML = summaryText;
                
                // Scroll to results
                solutionContainer.scrollIntoView({ behavior: 'smooth' });
            }
            
            // Create a tabular view of the solution
            function createSolutionTable(iterations) {
                solutionTableContainer.innerHTML = '';
                
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                
                // Create table header
                const headerRow = document.createElement('tr');
                const headers = ['Iteration', 'a', 'b', 'c = (a+b)/2', 'f(a)', 'f(b)', 'f(c)'];
                
                if (absoluteError.checked) {
                    headers.push('Abs Error');
                }
                
                if (relativeError.checked) {
                    headers.push('Rel Error (%)');
                }
                
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                iterations.forEach(iter => {
                    const row = document.createElement('tr');
                    
                    // Add cells
                    const cells = [
                        iter.iteration,
                        iter.a.toFixed(6),
                        iter.b.toFixed(6),
                        iter.c.toFixed(6),
                        iter.fa.toFixed(6),
                        iter.fb.toFixed(6),
                        iter.fc.toFixed(6)
                    ];
                    
                    if (absoluteError.checked) {
                        cells.push(iter.error !== null ? iter.error.toFixed(6) : 'N/A');
                    }
                    
                    if (relativeError.checked) {
                        cells.push(iter.relError !== null ? iter.relError.toFixed(6) : 'N/A');
                    }
                    
                    cells.forEach(cellText => {
                        const td = document.createElement('td');
                        td.textContent = cellText;
                        row.appendChild(td);
                    });
                    
                    tbody.appendChild(row);
                });
                
                table.appendChild(tbody);
                solutionTableContainer.appendChild(table);
            }
            
            // Initialize
            toggleIntervalInputs();
            
            // Create and populate the interval demo table for the example
            const intervalDemoTable = document.getElementById('interval-demo-table');
            
            // Function to create the interval demo table
            function createIntervalDemoTable() {
                // Example function: 2x^3 - 2x - 5
                const demoF = x => 2 * Math.pow(x, 3) - 2 * x - 5;
                
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.marginBottom = '15px';
                
                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                ['x', 'f(x)', 'Sign'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create body
                const tbody = document.createElement('tbody');
                
                // Add rows for values from -2 to 4
                for (let x = -2; x <= 4; x++) {
                    const row = document.createElement('tr');
                    const fx = demoF(x);
                    
                    // Highlight the row where sign changes
                    if ((x === 1 || x === 2)) {
                        row.style.backgroundColor = '#d5f5e3';
                        row.style.fontWeight = 'bold';
                    }
                    
                    // Add cells
                    const xCell = document.createElement('td');
                    xCell.textContent = x;
                    row.appendChild(xCell);
                    
                    const fxCell = document.createElement('td');
                    fxCell.textContent = fx.toFixed(2);
                    row.appendChild(fxCell);
                    
                    const signCell = document.createElement('td');
                    signCell.textContent = fx < 0 ? 'Negative' : 'Positive';
                    row.appendChild(signCell);
                    
                    tbody.appendChild(row);
                }
                
                table.appendChild(tbody);
                intervalDemoTable.appendChild(table);
            }
            
            // Create the demo table
            createIntervalDemoTable();
            
            // Function to explain the improved algorithm
            function addIntervalFindingExplanation() {
                const functionExample = '2x^3 - 2x - 5';
                const intervalExplanation = document.getElementById('interval-explanation');
                
                // Calculate function values at test points
                const f = x => 2 * Math.pow(x, 3) - 2 * x - 5;
                
                // Function to create a step explanation
                function createStepExplanation() {
                    const explanation = document.createElement('div');
                    explanation.style.marginTop = '15px';
                    explanation.innerHTML = `
                        <h4 style="margin-top: 10px; color: #27ae60;">How Our Improved Algorithm Works:</h4>
                        <ol style="margin-left: 20px;">
                            <li><strong>Start at zero:</strong> Evaluate f(0) = ${f(0).toFixed(2)} and check neighboring integers.</li>
                            <li><strong>Check consecutive integers:</strong> Instead of jumping to large intervals, we check f(0), f(1), f(2)... and f(-1), f(-2)... until we find a sign change.</li>
                            <li><strong>Detect sign change:</strong> When values have opposite signs (like between x=1 and x=2), we've found an interval containing a root.</li>
                            <li><strong>Apply bisection:</strong> Once we find an interval with a sign change, we apply the standard bisection method.</li>
                            <li><strong>Only if needed:</strong> If no roots are found between consecutive integers, only then do we check smaller increments or larger ranges.</li>
                        </ol>
                        <p>This approach typically finds roots in fewer iterations than starting with arbitrary large intervals.</p>
                    `;
                    return explanation;
                }
                
                intervalExplanation.appendChild(createStepExplanation());
            }
            
            // Add the explanation
            addIntervalFindingExplanation();
            
            // Trigger calculation immediately for the example equation
            if (functionInput.value.trim()) {
                calculateBtn.click();
            }
        });
    </script>
</body>
</html>